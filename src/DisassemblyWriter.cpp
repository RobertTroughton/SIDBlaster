// ==================================
//             SIDBlaster
//
//  Raistlin / Genesis Project (G*P)
// ==================================
#include "DisassemblyWriter.h"
#include "SIDLoader.h"
#include "cpu6510.h"

#include <algorithm>
#include <iostream>
#include <queue>
#include <set>
#include <functional>

namespace sidblaster {

    /**
     * @brief Constructor for DisassemblyWriter
     *
     * Initializes the disassembly writer with references to the CPU, SID loader,
     * memory analyzer, label generator, and code formatter.
     *
     * @param cpu Reference to the CPU
     * @param sid Reference to the SID loader
     * @param analyzer Reference to the memory analyzer
     * @param labelGenerator Reference to the label generator
     * @param formatter Reference to the code formatter
     */
    DisassemblyWriter::DisassemblyWriter(
        const CPU6510& cpu,
        const SIDLoader& sid,
        const MemoryAnalyzer& analyzer,
        const LabelGenerator& labelGenerator,
        const CodeFormatter& formatter)
        : cpu_(cpu),
        sid_(sid),
        analyzer_(analyzer),
        labelGenerator_(labelGenerator),
        formatter_(formatter) {
    }

    /**
     * @brief Generate an assembly file
     *
     * Creates a complete assembly language file for the disassembled SID,
     * including header comments, constants, and code.
     *
     * @param filename Output filename
     * @param sidLoad New SID load address
     * @param sidInit New SID init address
     * @param sidPlay New SID play address
     * @return Number of unused bytes removed
     */
    int DisassemblyWriter::generateAsmFile(
        const std::string& filename,
        u16 sidLoad,
        u16 sidInit,
        u16 sidPlay) {

        util::Logger::info("Generating assembly file: " + filename);

        // Open the output file
        std::ofstream file(filename);
        if (!file) {
            util::Logger::error("Failed to open output file: " + filename);
            return 0;
        }

        // Write file header
        file << "//; ------------------------------------------\n";
        file << "//; Generated by " << SIDBLASTER_VERSION << "\n";
        file << "//; \n";
        file << "//; Name: " << sid_.getHeader().name << "\n";
        file << "//; Author: " << sid_.getHeader().author << "\n";
        file << "//; Copyright: " << sid_.getHeader().copyright << "\n";
        file << "//; ------------------------------------------\n\n";

        // Output addresses as constants
        file << ".const SIDLoad = $" << util::wordToHex(sidLoad) << "\n";

        // Output hardware registers as constants
        outputHardwareConstants(file);

        // Output zero page defines
        emitZPDefines(file);

        // Disassemble to file
        int unusedByteCount = disassembleToFile(file);

        // Output unused byte count
        file << "//; " << unusedByteCount << " unused bytes zeroed out\n\n";

        file.close();

        return unusedByteCount;
    }

    /**
     * @brief Add an indirect memory access
     *
     * Records information about an indirect memory access for later analysis.
     * Enhanced to collect more detailed information about pointer usage.
     *
     * @param pc Program counter
     * @param zpAddr Zero page address
     * @param targetAddr Target address
     */
    void DisassemblyWriter::addIndirectAccess(u16 pc, u8 zpAddr, u16 targetAddr) {
        // Log the raw access for debugging
        static std::ofstream accessLog("indirect_access_raw.log", std::ios::app);

        if (accessLog) {
            accessLog << "INDIRECT ACCESS: PC=$" << util::wordToHex(pc)
                << " ZP=$" << util::byteToHex(zpAddr)
                << " Target=$" << util::wordToHex(targetAddr) << "\n";
        }

        // Get the sources of the ZP variables
        const auto& lowSource = cpu_.getWriteSourceInfo(zpAddr);
        const auto& highSource = cpu_.getWriteSourceInfo(zpAddr + 1);

        // Get the last instructions that wrote to these ZP addresses
        u16 lastWriteLow = cpu_.getLastWriteTo(zpAddr);
        u16 lastWriteHigh = cpu_.getLastWriteTo(zpAddr + 1);

        // Log these sources
        if (accessLog) {
            accessLog << "  ZP Low source: ";
            if (lowSource.type == RegisterSourceInfo::SourceType::Memory) {
                accessLog << "Memory addr=$" << util::wordToHex(lowSource.address)
                    << " value=$" << util::byteToHex(lowSource.value);
            }
            else {
                accessLog << "Not from memory";
            }
            accessLog << " (last write at PC=$" << util::wordToHex(lastWriteLow) << ")\n";

            accessLog << "  ZP High source: ";
            if (highSource.type == RegisterSourceInfo::SourceType::Memory) {
                accessLog << "Memory addr=$" << util::wordToHex(highSource.address)
                    << " value=$" << util::byteToHex(highSource.value);
            }
            else {
                accessLog << "Not from memory";
            }
            accessLog << " (last write at PC=$" << util::wordToHex(lastWriteHigh) << ")\n\n";
        }

        // Look for an existing record for this ZP address
        IndirectAccessInfo* existingInfo = nullptr;
        for (auto& existing : indirectAccesses_) {
            if (existing.zpAddr == zpAddr &&
                existing.sourceLowAddress == lowSource.address &&
                existing.sourceHighAddress == highSource.address) {
                existingInfo = &existing;
                break;
            }
        }

        // If not found, create a new entry
        if (!existingInfo) {
            IndirectAccessInfo info;
            info.instructionAddress = pc;
            info.zpAddr = zpAddr;
            info.lastWriteLow = lastWriteLow;
            info.lastWriteHigh = lastWriteHigh;

            // Capture source addresses when available
            if (lowSource.type == RegisterSourceInfo::SourceType::Memory) {
                info.sourceLowAddress = lowSource.address;
            }

            if (highSource.type == RegisterSourceInfo::SourceType::Memory) {
                info.sourceHighAddress = highSource.address;
            }

            // Add this target address
            info.targetAddresses.push_back(targetAddr);

            // Add to the collection
            indirectAccesses_.push_back(info);
        }
        else {
            // Add this target address to the existing entry if not already present
            if (std::find(existingInfo->targetAddresses.begin(),
                existingInfo->targetAddresses.end(),
                targetAddr) == existingInfo->targetAddresses.end()) {
                existingInfo->targetAddresses.push_back(targetAddr);

                // Log when we're adding an additional target
                if (accessLog) {
                    accessLog << "  Adding additional target $" << util::wordToHex(targetAddr)
                        << " to existing entry for ZP=$" << util::byteToHex(zpAddr)
                        << " (now has " << existingInfo->targetAddresses.size() << " targets)\n";
                }
            }
        }
    }

    /**
     * @brief Dump memory data flow to a log file
     * @param dataFlow The memory data flow structure
     * @param filename Output file path
     */
    void dumpMemoryDataFlow(const MemoryDataFlow& dataFlow, const std::string& filename) {
        std::ofstream file(filename);
        if (!file) {
            util::Logger::error("Failed to open data flow log file: " + filename);
            return;
        }

        file << "===== MEMORY DATA FLOW DUMP =====\n\n";

        // Write memory write sources
        file << "===== MEMORY WRITE SOURCES =====\n";
        file << "Format: destination_addr <- source_addr(s)\n\n";

        for (const auto& [destAddr, sources] : dataFlow.memoryWriteSources) {
            file << "$" << util::wordToHex(destAddr) << " <- ";

            if (sources.empty()) {
                file << "NO SOURCES\n";
            }
            else {
                for (size_t i = 0; i < sources.size(); i++) {
                    if (i > 0) file << ", ";
                    file << "$" << util::wordToHex(sources[i]);
                }
                file << "\n";
            }
        }

    }

    /**
     * @brief Process all recorded indirect accesses
     *
     * Analyzes indirect access patterns to identify address references
     * and pointer tables. Updated to use the new RelocationTable approach.
     */
    void DisassemblyWriter::processIndirectAccesses() {
        // First dump the data flow to aid debugging
        dumpMemoryDataFlow(cpu_.getMemoryDataFlow(), "dataflow.log");

        // Now build the relocation table
        buildRelocationTable();
    }

    /**
     * @brief Build the relocation table from indirect accesses and data flow
     *
     * Analyzes all indirect memory accesses and traces data flow chains
     * to build a consolidated table of all addresses needing relocation.
     */
    void DisassemblyWriter::buildRelocationTable() {
        if (indirectAccesses_.empty()) {
            return;
        }

        // Get memory data flow from CPU
        const auto& dataFlow = cpu_.getMemoryDataFlow();

        // Clear any existing entries in relocTable_
        relocTable_.clear();

        // Log file for debugging the relocation table building
        std::ofstream debugLog("relocation_debug.log");

        // Process each indirect access - now tracking multiple targets
        for (const auto& access : indirectAccesses_) {
            // Log for each entry
            if (debugLog) {
                debugLog << "Processing ZP=$" << util::byteToHex(access.zpAddr)
                    << " with " << access.targetAddresses.size() << " targets:\n";

                for (size_t i = 0; i < access.targetAddresses.size(); i++) {
                    debugLog << "  Target " << i << ": $" << util::wordToHex(access.targetAddresses[i]) << "\n";
                }

                debugLog << "  Low byte source: $" << util::wordToHex(access.sourceLowAddress) << "\n";
                debugLog << "  High byte source: $" << util::wordToHex(access.sourceHighAddress) << "\n\n";
            }

            // Use ONLY THE FIRST target address - this should be the original one we want
            // This is the key change to fix the issue
            if (!access.targetAddresses.empty()) {
                u16 targetAddr = access.targetAddresses[0]; // Use the FIRST target address

                if (debugLog) {
                    debugLog << "Selected target address: $" << util::wordToHex(targetAddr) << "\n";
                }

                // Process the source address for LOW byte
                if (access.sourceLowAddress != 0) {
                    // Add entry to relocation table with the FIRST target address
                    relocTable_.addEntry(access.sourceLowAddress, targetAddr, RelocationEntry::Type::Low);

                    // Mark for potential subdivision
                    const_cast<LabelGenerator&>(labelGenerator_).addPendingSubdivisionAddress(access.sourceLowAddress);

                    // Follow data flow chain
                    processRelocationChain(dataFlow, relocTable_, access.sourceLowAddress, targetAddr, RelocationEntry::Type::Low);
                }

                // Process the source address for HIGH byte
                if (access.sourceHighAddress != 0) {
                    // Add entry to relocation table with the FIRST target address
                    relocTable_.addEntry(access.sourceHighAddress, targetAddr, RelocationEntry::Type::High);

                    // Mark for potential subdivision
                    const_cast<LabelGenerator&>(labelGenerator_).addPendingSubdivisionAddress(access.sourceHighAddress);

                    // Follow data flow chain
                    processRelocationChain(dataFlow, relocTable_, access.sourceHighAddress, targetAddr, RelocationEntry::Type::High);
                }
            }
        }

        // Dump the final relocation table
        relocTable_.dumpToFile("relocation_table.log");
    }

    void DisassemblyWriter::processRelocationChain(
        const MemoryDataFlow& dataFlow,
        RelocationTable& relocTable,
        u16 addr,
        u16 targetAddr,
        RelocationEntry::Type relocType) {

        // Add entry with the EXACT target address as received - no adjustments
        relocTable.addEntry(addr, targetAddr, relocType);

        // Mark this source address for potential subdivision
        const_cast<LabelGenerator&>(labelGenerator_).addPendingSubdivisionAddress(addr);

        // Find any other memory locations that write to this address
        auto it = dataFlow.memoryWriteSources.find(addr);
        if (it != dataFlow.memoryWriteSources.end()) {
            // Process each source address that writes to this address
            for (u16 newAddr : it->second) {
                // Skip self-references to avoid infinite recursion
                if (newAddr != addr) {
                    // Use SAME target address for all chain entries to ensure consistency
                    processRelocationChain(dataFlow, relocTable, newAddr, targetAddr, relocType);
                }
            }
        }
    }

    /**
     * @brief Output hardware constants to the assembly file
     *
     * Identifies hardware components (like SID chips) that are accessed
     * in the code and generates appropriate constant definitions.
     *
     * @param file Output stream
     */
    void DisassemblyWriter::outputHardwareConstants(std::ofstream& file) {
        // Find all accessed hardware components

        // SID detection
        std::set<u16> sidBases;
        for (u16 addr = 0xD400; addr <= 0xD7FF; addr++) {
            if (analyzer_.getMemoryType(addr) & (MemoryType::Accessed)) {
                u16 base = addr & 0xFFE0; // Align to 32 bytes for SID
                sidBases.insert(base);
            }
        }

        // Ensure at least one SID is always present
        if (sidBases.empty()) {
            sidBases.insert(0xD400);
        }

        // Register SID bases
        int sidIndex = 0;
        for (u16 base : sidBases) {
            const std::string name = "SID" + std::to_string(sidIndex);

            // Register with label generator
            const_cast<LabelGenerator&>(labelGenerator_).addHardwareBase(
                HardwareType::SID, base, sidIndex, name);

            // Output to assembly file
            file << ".const " << name << " = $" << util::wordToHex(base) << "\n";

            sidIndex++;
        }

        // Future hardware component detection can be added here:
        // VIC-II detection (0xD000-0xD3FF)
        // CIA detection (0xDC00-0xDCFF for CIA1, 0xDD00-0xDDFF for CIA2)
        // etc.

        file << "\n";
    }

    /**
     * @brief Output zero page definitions to the assembly file
     *
     * Identifies zero page variables used by the code and generates
     * appropriate constant definitions.
     *
     * @param file Output stream
     */
    void DisassemblyWriter::emitZPDefines(std::ofstream& file) {
        // Collect all used zero page addresses
        std::set<u8> usedZP;
        for (u16 addr = 0x0000; addr <= 0x00FF; ++addr) {
            if (analyzer_.getMemoryType(addr) & MemoryType::Accessed) {
                usedZP.insert(static_cast<u8>(addr));
            }
        }

        if (usedZP.empty()) {
            return;
        }

        // Convert to vector for sorting
        std::vector<u8> zpList(usedZP.begin(), usedZP.end());
        std::sort(zpList.begin(), zpList.end());

        // Calculate ZP base
        u8 zpBase = 0xFF - static_cast<u8>(zpList.size()) + 1;

        // Output ZP defines
        file << ".const ZP_BASE = $" << util::byteToHex(zpBase) << "\n";
        for (size_t i = 0; i < zpList.size(); ++i) {
            std::string varName = "ZP_" + std::to_string(i);
            file << ".const " << varName << " = ZP_BASE + " << i << " // $" << util::byteToHex(zpList[i]) << "\n";

            // Add to label generator
            const_cast<LabelGenerator&>(labelGenerator_).addZeroPageVar(zpList[i], varName);
        }

        file << "\n";
    }

    /**
     * @brief Disassemble to the output file
     *
     * Performs the actual disassembly writing to the file, handling code,
     * data, and labels appropriately.
     *
     * @param file Output stream
     * @return Number of unused bytes removed
     */
    int DisassemblyWriter::disassembleToFile(std::ofstream& file) {
        u16 pc = sid_.getLoadAddress();
        file << "\n* = SIDLoad\n\n";

         const u16 sidEnd = sid_.getLoadAddress() + sid_.getDataSize();
        int unusedByteCount = 0;

        while (pc < sidEnd) {
            // Check if we need to output a label
            const std::string label = labelGenerator_.getLabel(pc);
            if (!label.empty() && (analyzer_.getMemoryType(pc) & MemoryType::Code)) {
                file << label << ":\n";
            }

            // Check if this is code or data
            if (analyzer_.getMemoryType(pc) & MemoryType::Code) {
                const u16 startPc = pc;
                const std::string line = formatter_.formatInstruction(pc);

                file << util::padToColumn(line, 96);
                file << " //; $" << util::wordToHex(startPc) << " - "
                    << util::wordToHex(pc - 1) << "\n";
            }
            else if (analyzer_.getMemoryType(pc) & MemoryType::Data) {
                // Format data bytes
                unusedByteCount += formatter_.formatDataBytes(
                    file,
                    pc,
                    sid_.getOriginalMemory(),
                    sid_.getOriginalMemoryBase(),
                    sidEnd,
                    relocTable_.getAllEntries(),
                    analyzer_.getMemoryTypes());
            }
            else {
                // Unknown memory type, just increment PC
                ++pc;
            }
        }

        return unusedByteCount;
    }

} // namespace sidblaster